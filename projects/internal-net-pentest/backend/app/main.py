from __future__ import annotations

from datetime import datetime, timedelta
from typing import Dict, List, Optional
from uuid import uuid4

import jwt
from fastapi import Depends, FastAPI, Header, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel, Field, validator

SECRET_KEY = "internal-net-pentest-secret"
ALGORITHM = "HS256"
TOKEN_EXPIRE_MINUTES = 30


class TokenRequest(BaseModel):
    username: str
    password: str


class TokenResponse(BaseModel):
    access_token: str
    token_type: str = "bearer"


class HostBase(BaseModel):
    hostname: str = Field(..., example="web-01")
    ip_address: str = Field(..., example="10.0.0.5")
    operating_system: str = Field(..., example="Ubuntu 22.04")
    criticality: str = Field(..., example="high")


class Host(HostBase):
    id: str = Field(default_factory=lambda: str(uuid4()))


class FindingBase(BaseModel):
    host_id: str
    severity: str
    description: str
    status: str = Field("open", description="Current remediation status")

    @validator("severity")
    def severity_level(cls, value: str) -> str:
        allowed = {"low", "medium", "high", "critical"}
        if value not in allowed:
            raise ValueError("Unsupported severity level")
        return value


class Finding(FindingBase):
    id: str = Field(default_factory=lambda: str(uuid4()))
    created_at: datetime = Field(default_factory=datetime.utcnow)


class AttackPathStep(BaseModel):
    from_host: str
    to_host: str
    technique: str = Field(..., example="lateral-movement")


class AttackPath(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid4()))
    name: str
    narrative: str
    steps: List[AttackPathStep]
    likelihood: str = Field("medium", description="Qualitative risk score")

    @validator("steps")
    def validate_steps(cls, value: List[AttackPathStep]) -> List[AttackPathStep]:
        if len(value) < 1:
            raise ValueError("Attack paths must contain at least one step")
        return value


class LateralMovementResult(BaseModel):
    reachable_hosts: List[str]
    description: str


app = FastAPI(title="Internal Network Pentest API")

# Allow local dev frontends; production deployments should restrict these origins.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

hosts: Dict[str, Host] = {}
findings: Dict[str, Finding] = {}
attack_paths: Dict[str, AttackPath] = {}


def create_access_token(username: str) -> str:
    expiration = datetime.utcnow() + timedelta(minutes=TOKEN_EXPIRE_MINUTES)
    payload = {"sub": username, "exp": expiration}
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)


def get_current_user(authorization: Optional[str] = Header(None)) -> str:
    if not authorization:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Missing token")
    scheme, _, token = authorization.partition(" ")
    if scheme.lower() != "bearer" or not token:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid authorization header")
    try:
        decoded = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return decoded["sub"]
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Token expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid token")


@app.get("/health")
def health() -> Dict[str, str]:
    return {"status": "ok"}


@app.post("/auth/token", response_model=TokenResponse)
def login(payload: TokenRequest) -> TokenResponse:
    # Simple credential check for demo purposes.
    if payload.username == "operator" and payload.password == "changeme":
        token = create_access_token(payload.username)
        return TokenResponse(access_token=token)
    raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid credentials")


@app.post("/hosts", response_model=Host, dependencies=[Depends(get_current_user)])
def create_host(host: HostBase) -> Host:
    new_host = Host(**host.dict())
    hosts[new_host.id] = new_host
    return new_host


@app.get("/hosts", response_model=List[Host], dependencies=[Depends(get_current_user)])
def list_hosts() -> List[Host]:
    return list(hosts.values())


@app.get("/hosts/{host_id}", response_model=Host, dependencies=[Depends(get_current_user)])
def get_host(host_id: str) -> Host:
    if host_id not in hosts:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Host not found")
    return hosts[host_id]


@app.put("/hosts/{host_id}", response_model=Host, dependencies=[Depends(get_current_user)])
def update_host(host_id: str, host: HostBase) -> Host:
    if host_id not in hosts:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Host not found")
    updated_host = Host(id=host_id, **host.dict())
    hosts[host_id] = updated_host
    return updated_host


@app.delete("/hosts/{host_id}", status_code=status.HTTP_204_NO_CONTENT, dependencies=[Depends(get_current_user)])
def delete_host(host_id: str) -> None:
    if host_id not in hosts:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Host not found")
    hosts.pop(host_id)


@app.post("/findings", response_model=Finding, dependencies=[Depends(get_current_user)])
def create_finding(finding: FindingBase) -> Finding:
    if finding.host_id not in hosts:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Host does not exist")
    new_finding = Finding(**finding.dict())
    findings[new_finding.id] = new_finding
    return new_finding


@app.get("/findings", response_model=List[Finding], dependencies=[Depends(get_current_user)])
def list_findings() -> List[Finding]:
    return list(findings.values())


@app.post("/attack-paths", response_model=AttackPath, dependencies=[Depends(get_current_user)])
def create_attack_path(path: AttackPath) -> AttackPath:
    for step in path.steps:
        if step.from_host not in hosts or step.to_host not in hosts:
            raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Attack path contains unknown host")
    attack_paths[path.id] = path
    return path


@app.get("/attack-paths", response_model=List[AttackPath], dependencies=[Depends(get_current_user)])
def list_attack_paths() -> List[AttackPath]:
    return list(attack_paths.values())


@app.get("/analysis/lateral-movement", response_model=LateralMovementResult, dependencies=[Depends(get_current_user)])
def lateral_movement_summary() -> LateralMovementResult:
    # Enumerate reachable hosts from each path hop to help prioritization.
    adjacency: Dict[str, List[str]] = {}
    for path in attack_paths.values():
        for step in path.steps:
            adjacency.setdefault(step.from_host, []).append(step.to_host)
    reachable = sorted({target for targets in adjacency.values() for target in targets})
    description = "Identified potential lateral movement targets based on modeled paths."
    return LateralMovementResult(reachable_hosts=reachable, description=description)


@app.delete("/reset")
def reset_state() -> Dict[str, str]:
    """Reset in-memory stores. Intended for test automation only."""
    hosts.clear()
    findings.clear()
    attack_paths.clear()
    return {"status": "reset"}
