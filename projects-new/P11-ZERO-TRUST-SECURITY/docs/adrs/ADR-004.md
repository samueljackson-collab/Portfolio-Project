# ADR-004: Observability Stack Selection

**Status:** Accepted  
**Date:** 2025-06-06

## Context
The Zero Trust Security platform must provide end-to-end visibility into authentication flows, policy evaluation, and service-to-service traffic across heterogeneous runtimes (VMs, containers, serverless). The observability solution needs to instrument data plane proxies and control-plane services uniformly, correlate events for incident response, and remain vendor-neutral for on-prem and cloud deployments. It should support high-cardinality labels (e.g., tenant, workload, policy version), enforce transport encryption, and minimize per-service configuration overhead.

## Decision
Adopt an OpenTelemetry-first observability stack with the following components:
- **Instrumentation:** Use OpenTelemetry SDKs and sidecar auto-instrumentation for services, plus Envoy/ingress exporters to emit metrics, traces, and logs via OTLP over mTLS.
- **Collection & Processing:** Deploy the OpenTelemetry Collector as a tiered pipeline (node-level agents plus regional gateways) to normalize, redact sensitive fields, and route signals.
- **Storage & Visualization:** Persist metrics in Prometheus-compatible storage (e.g., Cortex/Thanos for HA), traces in Tempo, and logs in Loki, all visualized through Grafana dashboards and alerts.
- **Governance:** Enforce schema and label conventions via collector processors and CI checks on dashboard/alert definitions stored as code.

## Alternatives
- **Vendor APM suite (proprietary agent):** Simplifies setup but reduces portability, increases licensing costs, and limits deep integration with custom policy metadata.
- **Metrics-only stack (Prometheus + Alertmanager):** Lower operational cost but lacks distributed tracing for policy decision latency analysis and cross-service causality.
- **Push-based logging without centralized schema control:** Easiest to adopt but risks inconsistent fields, weak correlation across signals, and higher MTTR.

## Consequences
- Enables consistent, encrypted telemetry export across all workloads with minimal app code changes.
- Provides rich correlation (metrics/logs/traces) for policy debugging, threat hunting, and SLO tracking.
- Increases platform footprint (collectors, storage backends) and requires capacity planning plus runbooks for multi-tenant scaling.
- Relies on disciplined label governance; drift can degrade query performance and alert quality.
